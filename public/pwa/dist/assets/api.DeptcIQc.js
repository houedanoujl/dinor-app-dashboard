import{l as e,r as t,b as o}from"./vendor.BeqKZlTx.js";const r=e("cache",()=>{const e=t(new Map),o=t(new Map),r=t(3e5);function n(t){const r=o.value.get(t);return!r||Date.now()>r?(e.value.delete(t),o.value.delete(t),null):e.value.get(t)}function a(){const t=Date.now();for(const[r,n]of o.value.entries())t>n&&(e.value.delete(r),o.value.delete(r))}return setInterval(a,3e4),{defaultTTL:r,set:function(t,n,a=r.value){e.value.set(t,n),o.value.set(t,Date.now()+a)},get:n,has:function(e){return null!==n(e)},remove:function(t){e.value.delete(t),o.value.delete(t)},clear:function(){e.value.clear(),o.value.clear()},clearExpired:a,getCacheInfo:function(){return{size:e.value.size,keys:Array.from(e.value.keys()),expired:Array.from(o.value.entries()).filter(([,e])=>Date.now()>e).map(([e])=>e)}}}});console.log("🚀 [Auth Store] Store d'authentification chargé avec les modifications!");const n=e("auth",()=>{const e=t(JSON.parse(localStorage.getItem("auth_user")||"null")),r=t(localStorage.getItem("auth_token")||null),n=t(!1),s=t(null),l=a(),c=o(()=>!!r.value&&!!e.value),u=o(()=>{var t;return(null==(t=e.value)?void 0:t.name)||""}),i=o(()=>{var t;return(null==(t=e.value)?void 0:t.email)||""}),h=e=>{r.value=e,e?localStorage.setItem("auth_token",e):localStorage.removeItem("auth_token")},g=t=>{e.value=t,t?localStorage.setItem("auth_user",JSON.stringify(t)):localStorage.removeItem("auth_user")},d=()=>{const t=localStorage.getItem("auth_token"),o=localStorage.getItem("auth_user");if(t&&o){r.value=t;try{const t=JSON.parse(o);t&&"object"==typeof t?(e.value=t,console.log("🔍 [Auth Store] Utilisateur restauré:",t)):(console.warn("🔍 [Auth Store] Données utilisateur invalides"),f())}catch(n){console.error("🔍 [Auth Store] Erreur parsing utilisateur:",n),f()}}},f=()=>{e.value=null,r.value=null,localStorage.removeItem("auth_token"),localStorage.removeItem("auth_user")};return d(),{user:e,token:r,loading:n,error:s,isAuthenticated:c,userName:u,userEmail:i,register:async e=>{n.value=!0,s.value=null;try{console.log("🔐 [Auth] Tentative d'inscription avec les données:",e),console.log("🔐 [Auth] Store API utilisé:",!!l);const t=await l.post("/auth/register",e);if(console.log("📄 [Auth] Données de réponse:",t),t.success)return h(t.data.token),g(t.data.user),console.log("✅ [Auth] Inscription réussie pour:",t.data.user.name),{success:!0,user:t.data.user};throw new Error(t.message||"Erreur lors de l'inscription")}catch(t){return console.error("❌ [Auth] Erreur d'inscription:",t.message),console.error("❌ [Auth] Stack trace:",t.stack),s.value=t.message,{success:!1,error:t.message}}finally{n.value=!1}},login:async t=>{if(c.value)return console.log("✅ [Auth] Utilisateur déjà connecté, pas besoin de se reconnecter"),{success:!0,user:e.value};n.value=!0,s.value=null;try{console.log("🔐 [Auth] Tentative de connexion pour:",t.email);const e=await l.post("/auth/login",t);if(console.log("📩 [Auth] Réponse de connexion:",{success:e.success}),e.success)return h(e.data.token),g(e.data.user),console.log("✅ [Auth] Connexion réussie pour:",e.data.user.name),{success:!0,user:e.data.user};throw new Error(e.message||"Erreur lors de la connexion")}catch(o){return console.error("❌ [Auth] Erreur de connexion:",o.message),s.value=o.message,{success:!1,error:o.message}}finally{n.value=!1}},logout:async()=>{n.value=!0;try{r.value&&await l.post("/auth/logout")}catch(e){console.error("Erreur lors de la déconnexion:",e)}finally{f(),n.value=!1,console.log("👋 [Auth] Déconnexion terminée")}},getProfile:async()=>{if(!r.value)return null;try{const e=await l.get("/auth/profile");if(e.success)return g(e.data),e.data}catch(e){console.error("Erreur lors de la récupération du profil:",e),e.message.includes("401")&&f()}return null},clearAuth:f,initAuth:d}}),a=e("api",()=>{const e=t(new Set),o=t(new Map),a=t(`${window.location.origin}/api/v1`),s=r(),l=n();function c(t,o){o?e.value.add(t):e.value.delete(t)}function u(e,t){t?o.value.set(e,t):o.value.delete(e)}async function i(e,t={}){const o=`${e}_${JSON.stringify(t)}`;if(console.log("🌐 [API Store] Nouvelle requête:",{endpoint:e,options:t,cacheKey:o}),t.method&&"GET"!==t.method||t.forceRefresh)t.forceRefresh&&console.log("🔄 [API Store] Rechargement forcé - cache ignoré");else{console.log("🔍 [API Store] Vérification du cache PWA...");const o=await async function(e,t={}){try{const o=`${e}_${JSON.stringify(t.params||{})}`,r=await fetch("/api/pwa/cache/get",{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({key:o})});if(r.ok){const e=await r.json();if(e.success&&e.cached)return e.data}}catch(o){console.log("ℹ️ [API Store] Cache PWA non accessible:",o.message)}return null}(e,t);if(o)return console.log("⚡ [API Store] Données trouvées dans le cache PWA:",o),o;console.log("❌ [API Store] Aucune donnée dans le cache PWA")}c(o,!0),u(o,null);try{const o=`${a.value}${e}`;console.log("📡 [API Store] URL complète:",o);const r={headers:{"Content-Type":"application/json",Accept:"application/json","X-Requested-With":"XMLHttpRequest",...t.headers},...t};l.token&&(r.headers.Authorization=`Bearer ${l.token}`,console.log("🔐 [API Store] Token d'authentification ajouté")),console.log("⚙️ [API Store] Configuration de la requête:",r),console.log("🚀 [API Store] Envoi de la requête fetch...");const n=await fetch(o,r);if(console.log("📩 [API Store] Réponse reçue:",{status:n.status,ok:n.ok}),!n.ok)throw console.error("❌ [API Store] Erreur HTTP:",n.status,n.statusText),new Error(`HTTP error! status: ${n.status}`);console.log("🔄 [API Store] Parsing JSON...");const s=await n.json();return console.log("✅ [API Store] Données JSON reçues:",s),t.method&&"GET"!==t.method||(console.log("💾 [API Store] Mise en cache PWA..."),await async function(e,t,o={}){try{const r=`${e}_${JSON.stringify(o.params||{})}`,n=o.cacheTTL||3600;await fetch("/api/pwa/cache/set",{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({key:r,value:t,ttl:n})})}catch(r){console.log("ℹ️ [API Store] Cache PWA non accessible pour la sauvegarde")}}(e,s,t)),s}catch(r){throw console.error("💥 [API Store] Erreur lors de la requête:",r),u(o,r.message),r}finally{c(o,!1),console.log("🏁 [API Store] Fin de la requête:",e)}}async function h(e,t={},o={}){const r=new URLSearchParams(t).toString();return i(r?`${e}?${r}`:e,{...o,method:"GET"})}function g(e){s.getCacheInfo().keys.filter(t=>t.includes(e)||new RegExp(e).test(t)).forEach(e=>s.remove(e))}return{loading:e,errors:o,baseURL:a,isLoading:function(t){return e.value.has(t)},getError:function(e){return o.value.get(e)},setLoading:c,setError:u,clearError:function(e){o.value.delete(e)},request:i,get:h,getFresh:async function(e,t={},o={}){const r=new URLSearchParams(t).toString(),n=r?`${e}?${r}`:e;return g(e),i(n,{...o,method:"GET",forceRefresh:!0})},post:async function(e,t,o={}){return i(e,{...o,method:"POST",body:JSON.stringify(t)})},put:async function(e,t,o={}){return i(e,{...o,method:"PUT",body:JSON.stringify(t)})},del:async function(e,t={}){return i(e,{...t,method:"DELETE"})},invalidateCache:g,preload:async function(e){const t=e.map(({endpoint:e,params:t,options:o})=>h(e,t,{...o,priority:"low"}).catch(()=>null));return Promise.allSettled(t)}}});export{n as a,a as u};
