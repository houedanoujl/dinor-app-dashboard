import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { useCacheStore } from './cache.js'
import { useAuthStore } from './auth'

export const useApiStore = defineStore('api', () => {
  // State
  const loading = ref(new Map())
  const errors = ref(new Map())
  const baseURL = ref(getBaseURL())
  
  // Cache store
  const cacheStore = useCacheStore()

  // Auth store
  const authStore = useAuthStore()

  function getBaseURL() {
    if (import.meta.env.DEV) {
      return '/api/v1'
    }
    return `${window.location.origin}/api/v1`
  }

  // Getters
  const isLoading = computed(() => (endpoint) => loading.value.get(endpoint) || false)
  const getError = computed(() => (endpoint) => errors.value.get(endpoint) || null)

  // Actions
  function setLoading(endpoint, value) {
    if (value) {
      loading.value.set(endpoint, true)
    } else {
      loading.value.delete(endpoint)
    }
  }

  function setError(endpoint, error) {
    if (error) {
      errors.value.set(endpoint, error)
    } else {
      errors.value.delete(endpoint)
    }
  }

  async function request(endpoint, options = {}) {
    const cacheKey = `${endpoint}_${JSON.stringify(options)}`
    console.log('üåê [API Store] Nouvelle requ√™te:', { endpoint, options, cacheKey })
    
    // Cache d√©sactiv√© - communication directe avec l'API
    // if ((!options.method || options.method === 'GET') && !options.forceRefresh) {
    //   console.log('üîç [API Store] V√©rification du cache PWA...')
    //   const cached = await checkPWACache(endpoint, options)
    //   if (cached) {
    //     console.log('‚ö° [API Store] Donn√©es trouv√©es dans le cache PWA:', cached)
    //     return cached
    //   } else {
    //     console.log('‚ùå [API Store] Aucune donn√©e dans le cache PWA')
    //   }
    // } else if (options.forceRefresh) {
    //   console.log('üîÑ [API Store] Rechargement forc√© - cache ignor√©')
    // }
    
    console.log('üåê [API Store] Communication directe avec l\'API (cache d√©sactiv√©)')

    setLoading(cacheKey, true)
    setError(cacheKey, null)

    try {
      const url = `${baseURL.value}${endpoint}`
      console.log('üì° [API Store] URL compl√®te:', url)
      
      const config = {
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-Requested-With': 'XMLHttpRequest',
          ...options.headers
        },
        ...options
      }
      
      // Ajouter le token d'authentification si disponible
      if (authStore.token) {
        config.headers.Authorization = `Bearer ${authStore.token}`
        console.log('üîê [API Store] Token d\'authentification ajout√©')
      }
      
      console.log('‚öôÔ∏è [API Store] Configuration de la requ√™te:', config)

      console.log('üöÄ [API Store] Envoi de la requ√™te fetch...')
      const response = await fetch(url, config)
      console.log('üì© [API Store] R√©ponse re√ßue:', { status: response.status, ok: response.ok })
      
      if (!response.ok) {
        console.error('‚ùå [API Store] Erreur HTTP:', response.status, response.statusText)
        
        // Gestion sp√©cifique des erreurs 401 (non autoris√©)
        if (response.status === 401) {
          console.warn('üîê [API Store] Erreur 401 - Session expir√©e ou utilisateur non connect√©')
          
          // Effacer l'authentification si elle existe
          if (authStore.token) {
            console.log('üóëÔ∏è [API Store] Suppression de la session expir√©e')
            authStore.clearAuth()
          }
          
          // Cr√©er une erreur explicite pour guider l'utilisateur
          const authError = new Error('Vous devez √™tre connect√© pour effectuer cette action. Veuillez vous connecter ou cr√©er un compte.')
          authError.type = 'AUTH_REQUIRED'
          authError.status = 401
          authError.actionRequired = 'LOGIN_OR_REGISTER'
          
          throw authError
        }
        
        // Pour les erreurs 422, on doit r√©cup√©rer les d√©tails de validation
        let errorData = null
        try {
          errorData = await response.json()
          console.log('üìÑ [API Store] Donn√©es d\'erreur d√©taill√©es:', errorData)
        } catch (jsonError) {
          console.warn('‚ö†Ô∏è [API Store] Impossible de parser les donn√©es d\'erreur JSON')
        }
        
        // Gestion des autres erreurs HTTP
        let errorMessage = `Erreur ${response.status}`
        
        switch (response.status) {
          case 403:
            errorMessage = 'Acc√®s non autoris√©. Vous n\'avez pas les permissions n√©cessaires.'
            break
          case 404:
            errorMessage = 'Ressource non trouv√©e.'
            break
          case 422:
            if (errorData?.message) {
              errorMessage = errorData.message
            } else {
              errorMessage = 'Donn√©es invalides. Veuillez v√©rifier vos informations.'
            }
            break
          case 429:
            errorMessage = 'Trop de requ√™tes. Veuillez patienter avant de r√©essayer.'
            break
          case 500:
            errorMessage = 'Erreur du serveur. Veuillez r√©essayer plus tard.'
            break
          case 503:
            errorMessage = 'Service temporairement indisponible. Veuillez r√©essayer plus tard.'
            break
          default:
            errorMessage = `Erreur de connexion (${response.status}). Veuillez v√©rifier votre connexion internet.`
        }
        
        const httpError = new Error(errorMessage)
        httpError.status = response.status
        httpError.type = 'HTTP_ERROR'
        
        // Ajouter les donn√©es d'erreur d√©taill√©es pour les erreurs de validation
        if (errorData) {
          httpError.response = { data: errorData }
        }
        
        throw httpError
      }

      console.log('üîÑ [API Store] Parsing JSON...')
      const data = await response.json()
      console.log('‚úÖ [API Store] Donn√©es JSON re√ßues:', data)
      
      // Cache d√©sactiv√© - pas de mise en cache PWA
      // if (!options.method || options.method === 'GET') {
      //   console.log('üíæ [API Store] Mise en cache PWA...')
      //   await setPWACache(endpoint, data, options)
      // }

      return data
    } catch (error) {
      console.error('üí• [API Store] Erreur lors de la requ√™te:', error)
      setError(cacheKey, error.message)
      throw error
    } finally {
      setLoading(cacheKey, false)
      console.log('üèÅ [API Store] Fin de la requ√™te:', endpoint)
    }
  }

  // Fonction pour v√©rifier le cache PWA
  async function checkPWACache(endpoint, options = {}) {
    try {
      const key = `${endpoint}_${JSON.stringify(options.params || {})}`;
      
      const response = await fetch('/api/pwa/cache/get', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ key })
      });

      if (response.ok) {
        const result = await response.json();
        if (result.success && result.cached) {
          return result.data;
        }
      }
    } catch (error) {
      console.log('‚ÑπÔ∏è [API Store] Cache PWA non accessible:', error.message);
    }
    return null;
  }

  // Fonction pour mettre en cache dans la PWA
  async function setPWACache(endpoint, data, options = {}) {
    try {
      const key = `${endpoint}_${JSON.stringify(options.params || {})}`;
      const ttl = options.cacheTTL || 3600; // Utiliser le TTL de l'option ou 1h par d√©faut
      
      await fetch('/api/pwa/cache/set', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ key, value: data, ttl })
      });
    } catch (error) {
      // Cache PWA non disponible - c'est normal en d√©veloppement
      console.log('‚ÑπÔ∏è [API Store] Cache PWA non accessible pour la sauvegarde');
    }
  }

  // D√©terminer le type de contenu depuis l'endpoint
  function getContentType(endpoint) {
    if (endpoint.includes('/recipes')) return 'recipes'
    if (endpoint.includes('/tips')) return 'tips'
    if (endpoint.includes('/events')) return 'events'
    if (endpoint.includes('/dinor-tv')) return 'videos'
    if (endpoint.includes('/categories')) return 'categories'
    return null
  }

  // Extraire les param√®tres pertinents pour le cache
  function extractParams(options) {
    const url = new URL(`http://example.com${options.url || ''}`)
    const params = {}
    
    for (const [key, value] of url.searchParams) {
      params[key] = value
    }
    
    return params
  }

  // M√©thodes sp√©cifiques
  async function get(endpoint, params = {}, options = {}) {
    const queryString = new URLSearchParams(params).toString()
    const fullEndpoint = queryString ? `${endpoint}?${queryString}` : endpoint
    return request(fullEndpoint, { ...options, method: 'GET' })
  }

  // M√©thode GET qui force le rechargement sans cache - d√©sactiv√© car plus de cache
  async function getFresh(endpoint, params = {}, options = {}) {
    const queryString = new URLSearchParams(params).toString()
    const fullEndpoint = queryString ? `${endpoint}?${queryString}` : endpoint
    // Cache d√©sactiv√© - pas d'invalidation n√©cessaire
    // invalidateCache(endpoint)
    return request(fullEndpoint, { ...options, method: 'GET' })
  }

  async function post(endpoint, data, options = {}) {
    return request(endpoint, {
      ...options,
      method: 'POST',
      body: JSON.stringify(data)
    })
  }

  async function put(endpoint, data, options = {}) {
    return request(endpoint, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(data)
    })
  }

  async function del(endpoint, options = {}) {
    return request(endpoint, {
      ...options,
      method: 'DELETE'
    })
  }

  // Invalider le cache pour un pattern donn√© - d√©sactiv√© car plus de cache
  function invalidateCache(pattern) {
    console.log('üóëÔ∏è [API Store] Invalidation du cache:', pattern, '- Cache d√©sactiv√©, requ√™te directe √† l\'API')
    
    // const cacheInfo = cacheStore.getCacheInfo()
    // const keysToRemove = cacheInfo.keys.filter(key => 
    //   key.includes(pattern) || new RegExp(pattern).test(key)
    // )
    
    // keysToRemove.forEach(key => cacheStore.remove(key))
    
    // Invalider le cache PWA via Service Worker
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({
        type: 'INVALIDATE_CACHE',
        pattern: pattern
      })
    }
  }

  // Forcer le rechargement complet - d√©sactiv√© car plus de cache local
  function forceRefresh() {
    console.log('üîÑ [API Store] Rechargement forc√© demand√© - Cache d√©sactiv√©, requ√™te directe √† l\'API')
    
    // Vider tous les caches locaux - d√©sactiv√©
    // cacheStore.clear()
    
    // Forcer le rechargement via Service Worker
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({
        type: 'FORCE_REFRESH'
      })
    }
  }

  // Supprimer tout le cache - d√©sactiv√© car plus de cache local
  function clearAllCache() {
    console.log('üóëÔ∏è [API Store] Suppression de tout le cache - Cache d√©sactiv√©, requ√™te directe √† l\'API')
    
    // Vider tous les caches locaux - d√©sactiv√©
    // cacheStore.clear()
    
    // Supprimer tout le cache via Service Worker
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({
        type: 'CLEAR_ALL_CACHE'
      })
    }
  }

  // √âcouter les messages du Service Worker pour invalider le cache
  function setupServiceWorkerListener() {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.addEventListener('message', (event) => {
        if (event.data && event.data.type === 'CACHE_INVALIDATED') {
          console.log('üîÑ [API Store] Cache invalid√© par le Service Worker:', event.data)
          const pattern = event.data.pattern || ''
          invalidateCache(pattern)
        }
      })
    }
  }

  // Initialiser l'√©couteur du Service Worker
  setupServiceWorkerListener()

  return {
    // State
    loading,
    errors,
    baseURL,
    
    // Getters
    isLoading,
    getError,
    
    // Actions
    setLoading,
    setError,
    request,
    get,
    getFresh,
    post,
    put,
    del,
    invalidateCache,
    forceRefresh,
    clearAllCache,
    checkPWACache,
    setPWACache
  }
})