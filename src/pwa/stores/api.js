import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { useCacheStore } from './cache'
import { useAuthStore } from './auth'

export const useApiStore = defineStore('api', () => {
  // State
  const loading = ref(new Set())
  const errors = ref(new Map())
  const baseURL = ref(getBaseURL())
  
  // Cache store
  const cacheStore = useCacheStore()

  // Auth store
  const authStore = useAuthStore()

  function getBaseURL() {
    if (import.meta.env.DEV) {
      return '/api/v1'
    }
    return `${window.location.origin}/api/v1`
  }

  // Actions
  function setLoading(key, isLoading) {
    if (isLoading) {
      loading.value.add(key)
    } else {
      loading.value.delete(key)
    }
  }

  function setError(key, error) {
    if (error) {
      errors.value.set(key, error)
    } else {
      errors.value.delete(key)
    }
  }

  function isLoading(key) {
    return loading.value.has(key)
  }

  function getError(key) {
    return errors.value.get(key)
  }

  function clearError(key) {
    errors.value.delete(key)
  }

  async function request(endpoint, options = {}) {
    const cacheKey = `${endpoint}_${JSON.stringify(options)}`
    console.log('üåê [API Store] Nouvelle requ√™te:', { endpoint, options, cacheKey })
    
    // V√©rifier le cache PWA d'abord (sauf pour POST/PUT/DELETE ou si forceRefresh est activ√©)
    if ((!options.method || options.method === 'GET') && !options.forceRefresh) {
      console.log('üîç [API Store] V√©rification du cache PWA...')
      const cached = await checkPWACache(endpoint, options)
      if (cached) {
        console.log('‚ö° [API Store] Donn√©es trouv√©es dans le cache PWA:', cached)
        return cached
      } else {
        console.log('‚ùå [API Store] Aucune donn√©e dans le cache PWA')
      }
    } else if (options.forceRefresh) {
      console.log('üîÑ [API Store] Rechargement forc√© - cache ignor√©')
    }

    setLoading(cacheKey, true)
    setError(cacheKey, null)

    try {
      const url = `${baseURL.value}${endpoint}`
      console.log('üì° [API Store] URL compl√®te:', url)
      
      const config = {
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-Requested-With': 'XMLHttpRequest',
          ...options.headers
        },
        ...options
      }
      
      // Ajouter le token d'authentification si disponible
      if (authStore.token) {
        config.headers.Authorization = `Bearer ${authStore.token}`
        console.log('üîê [API Store] Token d\'authentification ajout√©')
      }
      
      console.log('‚öôÔ∏è [API Store] Configuration de la requ√™te:', config)

      console.log('üöÄ [API Store] Envoi de la requ√™te fetch...')
      const response = await fetch(url, config)
      console.log('üì© [API Store] R√©ponse re√ßue:', { status: response.status, ok: response.ok })
      
      if (!response.ok) {
        console.error('‚ùå [API Store] Erreur HTTP:', response.status, response.statusText)
        
        // Gestion sp√©cifique des erreurs 401 (non autoris√©)
        if (response.status === 401) {
          console.warn('üîê [API Store] Erreur 401 - Session expir√©e ou utilisateur non connect√©')
          
          // Effacer l'authentification si elle existe
          if (authStore.token) {
            console.log('üóëÔ∏è [API Store] Suppression de la session expir√©e')
            authStore.clearAuth()
          }
          
          // Cr√©er une erreur explicite pour guider l'utilisateur
          const authError = new Error('Vous devez √™tre connect√© pour effectuer cette action. Veuillez vous connecter ou cr√©er un compte.')
          authError.type = 'AUTH_REQUIRED'
          authError.status = 401
          authError.actionRequired = 'LOGIN_OR_REGISTER'
          
          throw authError
        }
        
        // Pour les erreurs 422, on doit r√©cup√©rer les d√©tails de validation
        let errorData = null
        try {
          errorData = await response.json()
          console.log('üìÑ [API Store] Donn√©es d\'erreur d√©taill√©es:', errorData)
        } catch (jsonError) {
          console.warn('‚ö†Ô∏è [API Store] Impossible de parser les donn√©es d\'erreur JSON')
        }
        
        // Gestion des autres erreurs HTTP
        let errorMessage = `Erreur ${response.status}`
        
        switch (response.status) {
          case 403:
            errorMessage = 'Acc√®s non autoris√©. Vous n\'avez pas les permissions n√©cessaires.'
            break
          case 404:
            errorMessage = 'Ressource non trouv√©e.'
            break
          case 422:
            if (errorData?.message) {
              errorMessage = errorData.message
            } else {
              errorMessage = 'Donn√©es invalides. Veuillez v√©rifier vos informations.'
            }
            break
          case 429:
            errorMessage = 'Trop de requ√™tes. Veuillez patienter avant de r√©essayer.'
            break
          case 500:
            errorMessage = 'Erreur du serveur. Veuillez r√©essayer plus tard.'
            break
          case 503:
            errorMessage = 'Service temporairement indisponible. Veuillez r√©essayer plus tard.'
            break
          default:
            errorMessage = `Erreur de connexion (${response.status}). Veuillez v√©rifier votre connexion internet.`
        }
        
        const httpError = new Error(errorMessage)
        httpError.status = response.status
        httpError.type = 'HTTP_ERROR'
        
        // Ajouter les donn√©es d'erreur d√©taill√©es pour les erreurs de validation
        if (errorData) {
          httpError.response = { data: errorData }
        }
        
        throw httpError
      }

      console.log('üîÑ [API Store] Parsing JSON...')
      const data = await response.json()
      console.log('‚úÖ [API Store] Donn√©es JSON re√ßues:', data)
      
      // Mettre en cache les requ√™tes GET r√©ussies dans le cache PWA
      if (!options.method || options.method === 'GET') {
        console.log('üíæ [API Store] Mise en cache PWA...')
        await setPWACache(endpoint, data, options)
      }

      return data
    } catch (error) {
      console.error('üí• [API Store] Erreur lors de la requ√™te:', error)
      setError(cacheKey, error.message)
      throw error
    } finally {
      setLoading(cacheKey, false)
      console.log('üèÅ [API Store] Fin de la requ√™te:', endpoint)
    }
  }

  // Fonction pour v√©rifier le cache PWA
  async function checkPWACache(endpoint, options = {}) {
    try {
      const key = `${endpoint}_${JSON.stringify(options.params || {})}`;
      
      const response = await fetch('/api/pwa/cache/get', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ key })
      });

      if (response.ok) {
        const result = await response.json();
        if (result.success && result.cached) {
          return result.data;
        }
      }
    } catch (error) {
      console.log('‚ÑπÔ∏è [API Store] Cache PWA non accessible:', error.message);
    }
    return null;
  }

  // Fonction pour mettre en cache dans la PWA
  async function setPWACache(endpoint, data, options = {}) {
    try {
      const key = `${endpoint}_${JSON.stringify(options.params || {})}`;
      const ttl = options.cacheTTL || 3600; // Utiliser le TTL de l'option ou 1h par d√©faut
      
      await fetch('/api/pwa/cache/set', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ key, value: data, ttl })
      });
    } catch (error) {
      // Cache PWA non disponible - c'est normal en d√©veloppement
      console.log('‚ÑπÔ∏è [API Store] Cache PWA non accessible pour la sauvegarde');
    }
  }

  // D√©terminer le type de contenu depuis l'endpoint
  function getContentType(endpoint) {
    if (endpoint.includes('/recipes')) return 'recipes'
    if (endpoint.includes('/tips')) return 'tips'
    if (endpoint.includes('/events')) return 'events'
    if (endpoint.includes('/dinor-tv')) return 'videos'
    if (endpoint.includes('/categories')) return 'categories'
    return null
  }

  // Extraire les param√®tres pertinents pour le cache
  function extractParams(options) {
    const url = new URL(`http://example.com${options.url || ''}`)
    const params = {}
    
    for (const [key, value] of url.searchParams) {
      params[key] = value
    }
    
    return params
  }

  // M√©thodes sp√©cifiques
  async function get(endpoint, params = {}, options = {}) {
    const queryString = new URLSearchParams(params).toString()
    const fullEndpoint = queryString ? `${endpoint}?${queryString}` : endpoint
    return request(fullEndpoint, { ...options, method: 'GET' })
  }

  // M√©thode GET qui force le rechargement sans cache
  async function getFresh(endpoint, params = {}, options = {}) {
    const queryString = new URLSearchParams(params).toString()
    const fullEndpoint = queryString ? `${endpoint}?${queryString}` : endpoint
    // Invalider le cache avant de faire la requ√™te
    invalidateCache(endpoint)
    return request(fullEndpoint, { ...options, method: 'GET', forceRefresh: true })
  }

  async function post(endpoint, data, options = {}) {
    return request(endpoint, {
      ...options,
      method: 'POST',
      body: JSON.stringify(data)
    })
  }

  async function put(endpoint, data, options = {}) {
    return request(endpoint, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(data)
    })
  }

  async function del(endpoint, options = {}) {
    return request(endpoint, {
      ...options,
      method: 'DELETE'
    })
  }

  // Invalider le cache pour un pattern donn√©
  function invalidateCache(pattern) {
    const cacheInfo = cacheStore.getCacheInfo()
    const keysToRemove = cacheInfo.keys.filter(key => 
      key.includes(pattern) || new RegExp(pattern).test(key)
    )
    
    keysToRemove.forEach(key => cacheStore.remove(key))
  }

  // Pr√©charger des donn√©es
  async function preload(endpoints) {
    const promises = endpoints.map(({ endpoint, params, options }) => 
      get(endpoint, params, { ...options, priority: 'low' }).catch(() => null)
    )
    
    return Promise.allSettled(promises)
  }

  return {
    // State
    loading,
    errors,
    baseURL,
    
    // Getters
    isLoading,
    getError,
    
    // Actions
    setLoading,
    setError,
    clearError,
    request,
    get,
    getFresh,
    post,
    put,
    del,
    invalidateCache,
    preload
  }
})